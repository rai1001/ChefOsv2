// Bundled Edge Function - All dependencies inlined
// Generated by deploy-functions.js

// === types.ts ===
/**
 * Shared TypeScript types for Supabase Edge Functions
 * These types are used across all AI-related Edge Functions
 */

interface ScannedItem {
  name: string;
  quantity?: number;
  unit?: string;
  unitPrice?: number;
  totalPrice?: number;
  category?: string;
  code?: string;
  description?: string;
}

interface ScannedDocumentResult {
  items: ScannedItem[];
  rawText?: string;
  metadata?: {
    totalAmount?: number;
    currency?: string;
    date?: string;
    vendor?: string;
    documentType?: 'invoice' | 'delivery_note' | 'menu' | 'sports_menu' | 'other';
  };
}

interface NutritionalInfo {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  fiber?: number;
  sugar?: number;
  sodium?: number;
}

interface EnrichedIngredientData {
  nutritionalInfo: NutritionalInfo;
  allergens: string[];
  category?: string;
  seasonality?: string[];
}

interface AIRequestOptions {
  temperature?: number;
  maxOutputTokens?: number;
  topP?: number;
  topK?: number;
  jsonMode?: boolean;
  model?: string;
}

interface AIUsageMetrics {
  inputTokens: number;
  outputTokens: number;
  totalTokens: number;
  estimatedCost: number; // in USD
}

interface AIResponse {
  text: string;
  usage?: AIUsageMetrics;
}

// Request/Response types for Edge Functions
interface ScanDocumentRequest {
  imageBase64: string;
  type?: 'invoice' | 'menu' | 'sports_menu' | 'delivery_note';
  outletId?: string;
}

interface ScanDocumentResponse {
  success: boolean;
  data?: ScannedDocumentResult;
  usage?: AIUsageMetrics;
  error?: string;
}

interface EnrichIngredientRequest {
  ingredientName: string;
  outletId?: string;
}

interface EnrichIngredientResponse {
  success: boolean;
  data?: EnrichedIngredientData;
  usage?: AIUsageMetrics;
  error?: string;
}

// Gemini API types
interface GeminiContent {
  parts: Array<{
    text?: string;
    inline_data?: {
      mime_type: string;
      data: string;
    };
  }>;
  role?: string;
}

interface GeminiRequest {
  contents: GeminiContent[];
  generationConfig?: {
    temperature?: number;
    topK?: number;
    topP?: number;
    maxOutputTokens?: number;
    responseMimeType?: string;
  };
  safetySettings?: Array<{
    category: string;
    threshold: string;
  }>;
}

interface GeminiResponse {
  candidates?: Array<{
    content: {
      parts: Array<{
        text: string;
      }>;
      role: string;
    };
    finishReason: string;
    safetyRatings?: Array<{
      category: string;
      probability: string;
    }>;
  }>;
  usageMetadata?: {
    promptTokenCount: number;
    candidatesTokenCount: number;
    totalTokenCount: number;
  };
}

// === cors.ts ===
/**
 * CORS utilities for Supabase Edge Functions
 * Handles Cross-Origin Resource Sharing headers
 */

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

/**
 * Creates a Response with CORS headers
 */
function createCorsResponse(body: any, init?: ResponseInit): Response {
  return new Response(JSON.stringify(body), {
    ...init,
    headers: {
      ...corsHeaders,
      'Content-Type': 'application/json',
      ...init?.headers,
    },
  });
}

/**
 * Creates an error Response with CORS headers
 */
function createErrorResponse(error: string, status = 400): Response {
  return createCorsResponse(
    {
      success: false,
      error,
    },
    { status }
  );
}

/**
 * Creates a success Response with CORS headers
 */
function createSuccessResponse<T>(data: T, usage?: any): Response {
  return createCorsResponse({
    success: true,
    data,
    usage,
  });
}

/**
 * Handles OPTIONS requests for CORS preflight
 */
function handleCorsPreflightRequest(): Response {
  return new Response('ok', { headers: corsHeaders });
}

// === gemini-client.ts ===
/**
 * Gemini API Client for Supabase Edge Functions
 * Handles all interactions with Google's Gemini API
 */

class GeminiClient {
  private apiKey: string;
  private baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models';
  private defaultModel = 'gemini-2.0-flash-exp';

  constructor(apiKey: string) {
    if (!apiKey) {
      throw new Error('Gemini API Key is required');
    }
    this.apiKey = apiKey;
  }

  /**
   * Calculate estimated cost based on token usage
   * Pricing: Input $0.10/1M tokens, Output $0.40/1M tokens
   */
  private calculateCost(usage: AIUsageMetrics): number {
    const inputCost = (usage.inputTokens / 1_000_000) * 0.1;
    const outputCost = (usage.outputTokens / 1_000_000) * 0.4;
    return inputCost + outputCost;
  }

  /**
   * Parse usage metadata from Gemini response
   */
  private parseUsage(response: GeminiResponse): AIUsageMetrics | undefined {
    if (!response.usageMetadata) return undefined;

    const usage: AIUsageMetrics = {
      inputTokens: response.usageMetadata.promptTokenCount || 0,
      outputTokens: response.usageMetadata.candidatesTokenCount || 0,
      totalTokens: response.usageMetadata.totalTokenCount || 0,
      estimatedCost: 0,
    };

    usage.estimatedCost = this.calculateCost(usage);
    return usage;
  }

  /**
   * Generate text from a prompt
   */
  async generateText(
    prompt: string,
    options: AIRequestOptions = {}
  ): Promise<{ text: string; usage?: AIUsageMetrics }> {
    const model = options.model || this.defaultModel;
    const url = `${this.baseUrl}/${model}:generateContent?key=${this.apiKey}`;

    const request: GeminiRequest = {
      contents: [
        {
          parts: [{ text: prompt }],
        },
      ],
      generationConfig: {
        temperature: options.temperature ?? 0.7,
        topK: options.topK ?? 40,
        topP: options.topP ?? 0.95,
        maxOutputTokens: options.maxOutputTokens ?? 2048,
      },
    };

    // Enable JSON mode if requested
    if (options.jsonMode) {
      request.generationConfig!.responseMimeType = 'application/json';
    }

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Gemini API Error: ${response.status} - ${errorText}`);
    }

    const data: GeminiResponse = await response.json();

    if (!data.candidates || data.candidates.length === 0) {
      throw new Error('No response candidates from Gemini API');
    }

    const text = data.candidates[0].content.parts[0].text;
    const usage = this.parseUsage(data);

    return { text, usage };
  }

  /**
   * Analyze an image with a prompt
   */
  async analyzeImage(
    imageBase64: string,
    prompt: string,
    options: AIRequestOptions = {}
  ): Promise<{ text: string; usage?: AIUsageMetrics }> {
    const model = options.model || this.defaultModel;
    const url = `${this.baseUrl}/${model}:generateContent?key=${this.apiKey}`;

    // Clean base64 string (remove data URI prefix if present)
    const cleanBase64 = imageBase64.replace(/^data:image\/\w+;base64,/, '');

    // Determine MIME type from base64 or default to JPEG
    let mimeType = 'image/jpeg';
    if (imageBase64.startsWith('data:')) {
      const match = imageBase64.match(/^data:(image\/\w+);base64,/);
      if (match) mimeType = match[1];
    }

    const request: GeminiRequest = {
      contents: [
        {
          parts: [
            { text: prompt },
            {
              inline_data: {
                mime_type: mimeType,
                data: cleanBase64,
              },
            },
          ],
        },
      ],
      generationConfig: {
        temperature: options.temperature ?? 0.4, // Lower temp for structured extraction
        topK: options.topK ?? 40,
        topP: options.topP ?? 0.95,
        maxOutputTokens: options.maxOutputTokens ?? 2048,
      },
    };

    // Enable JSON mode if requested
    if (options.jsonMode) {
      request.generationConfig!.responseMimeType = 'application/json';
    }

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Gemini API Error: ${response.status} - ${errorText}`);
    }

    const data: GeminiResponse = await response.json();

    if (!data.candidates || data.candidates.length === 0) {
      throw new Error('No response candidates from Gemini API');
    }

    const text = data.candidates[0].content.parts[0].text;
    const usage = this.parseUsage(data);

    return { text, usage };
  }

  /**
   * Helper method to parse JSON from Gemini response
   * Handles common issues like markdown code blocks
   */
  parseJSON<T = any>(text: string): T {
    // Remove markdown code blocks if present
    let cleaned = text
      .replace(/```json\n?/g, '')
      .replace(/```\n?/g, '')
      .trim();

    try {
      return JSON.parse(cleaned);
    } catch (error) {
      // Try to find JSON object in the text
      const jsonMatch = cleaned.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        try {
          return JSON.parse(jsonMatch[0]);
        } catch {
          throw new Error(`Failed to parse JSON from Gemini response: ${error}`);
        }
      }
      throw new Error(`Failed to parse JSON from Gemini response: ${error}`);
    }
  }
}

/**
 * Create a GeminiClient instance from environment variable
 */
function createGeminiClient(): GeminiClient {
  const apiKey = Deno.env.get('GEMINI_API_KEY');
  if (!apiKey) {
    throw new Error(
      'GEMINI_API_KEY environment variable is not set. Please configure it in Supabase secrets.'
    );
  }
  return new GeminiClient(apiKey);
}

// === prompts.ts ===
/**
 * AI Prompts for Edge Functions
 * Migrated from packages/web/src/services/ai/prompts.ts
 */

const DOCUMENT_SCIENTIST_PROMPT = `You are an expert document analysis scientist specialized in HORECA (Hotel, Restaurant, Cafe) fiscal and operational documents.
You extract structured data from invoices, delivery notes, and inventory sheets with extreme precision.`;

const NUTRITION_EXPERT_PROMPT = `You are a certified nutrition expert and food safety scientist specialized in EU Regulation 1169/2011 and HACCP standards.`;

/**
 * Prompt for scanning invoices and delivery notes
 */
function getInvoiceScannerPrompt(): string {
  return `${DOCUMENT_SCIENTIST_PROMPT}

Analiza esta factura o albarán de proveedor alimentario. Extrae TODA la información en formato JSON estructurado.

REGLAS CRÍTICAS:
1. Distingue entre "Factura" y "Albarán" (busca texto "FACTURA" o "ALBARÁN")
2. Extrae TODOS los artículos de línea con cantidades exactas
3. Valida que suma de líneas = total (marca si hay discrepancia)
4. Parsea fechas a formato YYYY-MM-DD independientemente del formato original
5. Convierte TODOS los precios a Number (no strings)
6. Para campos ilegibles: usa null (NUNCA adivines)
7. Respeta los decimales exactos (importante para IVA)

Devuelve ÚNICAMENTE este JSON válido (sin markdown, sin \`\`\`json):
{
    "documentType": "Factura" | "Albarán",
    "documentNumber": "Número de factura/albarán",
    "supplierName": "Nombre legal del proveedor",
    "supplierTaxId": "NIF/CIF si visible",
    "issueDate": "YYYY-MM-DD",
    "subtotal": <número sin IVA>,
    "taxRate": <porcentaje IVA como número: 21, 10, 4>,
    "taxAmount": <importe del IVA>,
    "totalCost": <número total con IVA>,
    "items": [
        {
            "code": "Código/SKU del producto si visible",
            "description": "Descripción exacta del artículo",
            "quantity": <número>,
            "unit": "kg" | "l" | "u" | "caja" | "bandeja" | etc,
            "unitPrice": <precio unitario>,
            "lineTotal": <total de la línea>
        }
    ],
    "currency": "EUR",
    "notes": "Anotaciones manuscritas o sellos si existen"
}`;
}

/**
 * Prompt for scanning generic documents (simplified version)
 */
function getDocumentScannerPrompt(): string {
  return `${DOCUMENT_SCIENTIST_PROMPT}

Analiza este documento (Factura, Albarán, Menú o similar).
Extrae los items en formato JSON estricto.

Estructura esperada:
{
  "items": [
    {
      "name": "Nombre del producto o plato",
      "quantity": 1,
      "unit": "kg/un/L",
      "price": 10.5,
      "description": "Descripción si existe"
    }
  ],
  "metadata": {
    "totalAmount": 12.5,
    "date": "2025-01-03",
    "vendor": "Nombre del proveedor si visible"
  }
}

Si es un menú, usa quantity=1 por defecto.
Devuelve SOLO el JSON sin markdown (sin \`\`\`json).`;
}

/**
 * Prompt for scanning sports menus (BEO style)
 */
function getSportsMenuScannerPrompt(): string {
  return `${DOCUMENT_SCIENTIST_PROMPT}

Analiza este menú deportivo (BEO - Banquet Event Order style).

Extrae TODOS los platos y bebidas con sus detalles.

Devuelve ÚNICAMENTE este JSON (sin markdown):
{
  "eventName": "Nombre del evento si visible",
  "eventDate": "YYYY-MM-DD si visible",
  "pax": <número de comensales si visible>,
  "items": [
    {
      "name": "Nombre del plato/bebida",
      "category": "Starter" | "Main" | "Dessert" | "Beverage" | "Snack",
      "quantity": 1,
      "description": "Descripción si existe",
      "allergens": ["Lista de alérgenos si se mencionan"]
    }
  ]
}
`;
}

/**
 * Prompt for enriching ingredient data with nutritional info
 */
function getIngredientEnrichmentPrompt(ingredientName: string): string {
  return `${NUTRITION_EXPERT_PROMPT}

Proporciona información nutricional detallada y alérgenos para el siguiente ingrediente:
"${ingredientName}"

Devuelve ÚNICAMENTE este JSON (sin markdown):
{
  "nutritionalInfo": {
    "calories": <kcal por 100g>,
    "protein": <gramos por 100g>,
    "carbs": <gramos por 100g>,
    "fat": <gramos por 100g>,
    "fiber": <gramos por 100g>,
    "sugar": <gramos por 100g>,
    "sodium": <mg por 100g>
  },
  "allergens": ["Lista de alérgenos según EU 1169/2011"],
  "category": "Categoría del ingrediente (Vegetables, Meat, Dairy, etc)",
  "seasonality": ["Meses de temporada si aplica"]
}

Usa datos promedio si existen variaciones por tipo/variedad.`;
}

/**
 * Prompt for generating a menu based on constraints
 */
function getMenuGenerationPrompt(params: any): string {
  return `You are an expert Executive Chef specialized in menu planning, food cost optimization, and culinary creativity.

Generate a ${params.type || 'weekly'} menu for a ${params.outletType || 'restaurant'} with the following constraints:
- Start Date: ${params.startDate || 'Next Monday'}
- Duration: ${params.duration || 7} days
- Style/Cuisine: ${params.cuisine || 'International'}
- Budget Level: ${params.budget || 'Medium'}
- Special Requirements: ${params.requirements || 'None'}

Return ONLY a valid JSON object with the following structure (no markdown):
{
  "name": "Creative Name for the Menu",
  "description": "Brief description of the culinary concept",
  "sections": [
    {
      "name": "Monday Lunch" (or category name),
      "items": [
        {
          "name": "Dish Name",
          "description": "Short appetizing description",
          "price": 12.5 (suggested selling price if applicable),
          "tags": ["Vegan", "GF", etc],
          "allergens": ["Gluten", "Dairy", etc]
        }
      ]
    }
  ]
}`;
}

/**
 * Prompt for Kitchen Copilot Chat
 */
function getKitchenCopilotPrompt(): string {
  return `You are "ChefOS Copilot", an advanced AI kitchen assistant.
You help chefs with:
- Recipe ideas and modifications
- Food safety regulations (HACCP)
- Cost calculations and menu engineering
- Staff management advice
- Operational troubleshooting

Your tone is professional, concise, and helpful (Chef to Chef).
Always prioritize food safety and profitability.
If asked about specific data in the system (inventory, recipes), ask the user to provide the context or explain that you typically need access to that specific data.`;
}

// === Main Function ===
/**
 * Supabase Edge Function: enrich-ingredient
 *
 * Enriches ingredient data with nutritional information and allergens
 * Uses Gemini AI to provide detailed nutritional data per EU Regulation 1169/2011
 * Updated: 2026-01-04 - Using Gemini 2.0 Flash
 */

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import {
  handleCorsPreflightRequest,
  createErrorResponse,
  createSuccessResponse,
} from '../_shared/cors.ts';

serve(async (req: Request) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return handleCorsPreflightRequest();
  }

  // Only accept POST requests
  if (req.method !== 'POST') {
    return createErrorResponse('Method not allowed. Use POST.', 405);
  }

  try {
    // Parse request body
    const body: EnrichIngredientRequest = await req.json();

    // Validate required fields
    if (!body.ingredientName) {
      return createErrorResponse('ingredientName is required');
    }

    // Get Gemini client
    const gemini = createGeminiClient();

    // Get enrichment prompt
    const prompt = getIngredientEnrichmentPrompt(body.ingredientName);

    // Generate enrichment data
    const { text, usage } = await gemini.generateText(prompt, {
      temperature: 0.3, // Low temperature for factual data
      maxOutputTokens: 1024,
    });

    // Parse the JSON response
    let enrichedData: EnrichedIngredientData;
    try {
      enrichedData = gemini.parseJSON<EnrichedIngredientData>(text);
    } catch (parseError) {
      console.error('Failed to parse Gemini response as JSON:', text);
      return createErrorResponse(
        `AI returned invalid JSON. Raw response: ${text.substring(0, 200)}...`
      );
    }

    // Log usage for monitoring
    if (usage) {
      console.log('Gemini API Usage:', {
        outletId: body.outletId,
        ingredient: body.ingredientName,
        inputTokens: usage.inputTokens,
        outputTokens: usage.outputTokens,
        cost: usage.estimatedCost.toFixed(6),
      });
    }

    return createSuccessResponse(enrichedData, usage);
  } catch (error: any) {
    console.error('Error in enrich-ingredient function:', error);

    // Return user-friendly error message
    const errorMessage = error.message || 'Unknown error occurred';
    return createErrorResponse(`Failed to enrich ingredient: ${errorMessage}`, 500);
  }
});
/**
 * Supabase Edge Function: enrich-ingredient
 *
 * Enriches ingredient data with nutritional information and allergens
 * Uses Gemini AI to provide detailed nutritional data per EU Regulation 1169/2011
 * Updated: 2026-01-04 - Using Gemini 2.0 Flash
 */

import {
  handleCorsPreflightRequest,
  createErrorResponse,
  createSuccessResponse,
} from '../_shared/cors.ts';
import { createGeminiClient } from '../_shared/gemini-client.ts';
import { getIngredientEnrichmentPrompt } from '../_shared/prompts.ts';
import type { EnrichIngredientRequest, EnrichedIngredientData } from '../_shared/types.ts';

serve(async (req: Request) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return handleCorsPreflightRequest();
  }

  // Only accept POST requests
  if (req.method !== 'POST') {
    return createErrorResponse('Method not allowed. Use POST.', 405);
  }

  try {
    // Parse request body
    const body: EnrichIngredientRequest = await req.json();

    // Validate required fields
    if (!body.ingredientName) {
      return createErrorResponse('ingredientName is required');
    }

    // Get Gemini client
    const gemini = createGeminiClient();

    // Get enrichment prompt
    const prompt = getIngredientEnrichmentPrompt(body.ingredientName);

    // Generate enrichment data
    const { text, usage } = await gemini.generateText(prompt, {
      temperature: 0.3, // Low temperature for factual data
      maxOutputTokens: 1024,
    });

    // Parse the JSON response
    let enrichedData: EnrichedIngredientData;
    try {
      enrichedData = gemini.parseJSON<EnrichedIngredientData>(text);
    } catch (parseError) {
      console.error('Failed to parse Gemini response as JSON:', text);
      return createErrorResponse(
        `AI returned invalid JSON. Raw response: ${text.substring(0, 200)}...`
      );
    }

    // Log usage for monitoring
    if (usage) {
      console.log('Gemini API Usage:', {
        outletId: body.outletId,
        ingredient: body.ingredientName,
        inputTokens: usage.inputTokens,
        outputTokens: usage.outputTokens,
        cost: usage.estimatedCost.toFixed(6),
      });
    }

    return createSuccessResponse(enrichedData, usage);
  } catch (error: any) {
    console.error('Error in enrich-ingredient function:', error);

    // Return user-friendly error message
    const errorMessage = error.message || 'Unknown error occurred';
    return createErrorResponse(`Failed to enrich ingredient: ${errorMessage}`, 500);
  }
});
