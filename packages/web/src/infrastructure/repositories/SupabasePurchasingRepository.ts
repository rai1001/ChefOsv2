import { injectable } from 'inversify';
import { supabase } from '@/config/supabase';
import {
  PurchaseOrder,
  Money,
  IPurchaseOrderRepository,
  CreatePurchaseOrderDTO,
  ApprovePurchaseOrderDTO,
  PurchaseOrderStatus,
} from '@culinaryos/core';

@injectable()
export class SupabasePurchasingRepository implements IPurchaseOrderRepository {
  async create(dto: CreatePurchaseOrderDTO): Promise<PurchaseOrder> {
    const row = {
      outlet_id: dto.outletId,
      supplier_id: dto.supplier,
      items: dto.lines,
      status: 'draft',
      created_by: 'system', // Placeholder
    };
    const { data, error } = await supabase.from('purchase_orders').insert(row).select().single();
    if (error) throw error;
    return this.mapToDomain(data);
  }

  async findById(id: string): Promise<PurchaseOrder | null> {
    const { data, error } = await supabase
      .from('purchase_orders')
      .select('*')
      .eq('id', id)
      .single();
    if (error) return null;
    return this.mapToDomain(data);
  }

  async findByOutletId(outletId: string): Promise<PurchaseOrder[]> {
    const { data, error } = await supabase
      .from('purchase_orders')
      .select('*')
      .eq('outlet_id', outletId);
    if (error) throw error;
    return (data || []).map(this.mapToDomain);
  }

  async findByStatus(outletId: string, status: PurchaseOrderStatus): Promise<PurchaseOrder[]> {
    const { data, error } = await supabase
      .from('purchase_orders')
      .select('*')
      .eq('outlet_id', outletId)
      .eq('status', status);
    if (error) throw error;
    return (data || []).map(this.mapToDomain);
  }

  async findAutoGenerated(outletId: string): Promise<PurchaseOrder[]> {
    // Placeholder filtering
    const { data, error } = await supabase
      .from('purchase_orders')
      .select('*')
      .eq('outlet_id', outletId)
      .eq('is_auto_generated', true);
    if (error) throw error;
    return (data || []).map(this.mapToDomain);
  }

  async approve(dto: ApprovePurchaseOrderDTO): Promise<PurchaseOrder> {
    const { data, error } = await supabase
      .from('purchase_orders')
      .update({ status: 'approved', approved_at: new Date().toISOString() }) // Simplified
      .eq('id', dto.orderId)
      .select()
      .single();
    if (error) throw error;
    return this.mapToDomain(data);
  }

  async update(id: string, updates: Partial<PurchaseOrder>): Promise<PurchaseOrder> {
    const rowUpdates = this.mapToRowPartial(updates);
    const { data, error } = await supabase
      .from('purchase_orders')
      .update(rowUpdates)
      .eq('id', id)
      .select()
      .single();
    if (error) throw error;
    return this.mapToDomain(data);
  }

  async updateStatus(id: string, status: PurchaseOrderStatus): Promise<PurchaseOrder> {
    const { data, error } = await supabase
      .from('purchase_orders')
      .update({ status })
      .eq('id', id)
      .select()
      .single();
    if (error) throw error;
    return this.mapToDomain(data);
  }

  async delete(id: string): Promise<void> {
    const { error } = await supabase.from('purchase_orders').delete().eq('id', id);
    if (error) throw error;
  }

  // Legacy compat
  async getOrdersByOutlet(outletId: string): Promise<PurchaseOrder[]> {
    return this.findByOutletId(outletId);
  }

  async createOrder(order: PurchaseOrder): Promise<void> {
    const { error } = await supabase.from('purchase_orders').insert(this.mapToRow(order));
    if (error) throw error;
  }

  async updateOrder(id: string, order: Partial<PurchaseOrder>): Promise<void> {
    const { error } = await supabase
      .from('purchase_orders')
      .update(this.mapToRowPartial(order))
      .eq('id', id);
    if (error) throw error;
  }

  private mapToDomain(row: any): PurchaseOrder {
    return {
      id: row.id,
      outletId: row.outlet_id,
      orderNumber: row.id.substring(0, 8).toUpperCase(),
      supplier: row.supplier_id,
      status: row.status as any,
      lines: row.items || [],
      total: new Money(row.total_amount || 0, 'EUR'),
      isAutoGenerated: false,
      expectedDeliveryDate: row.delivery_date ? new Date(row.delivery_date) : undefined,
      actualDeliveryDate: undefined,
      notes: row.notes,
      createdBy: row.created_by,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
      approvedAt: undefined,
      subtotal: new Money(row.total_amount || 0, 'EUR'),
      tax: new Money(0, 'EUR'),
    } as unknown as PurchaseOrder;
  }

  private mapToRow(order: PurchaseOrder): any {
    return {
      id: order.id,
      outlet_id: order.outletId,
      supplier_id: order.supplier,
      status: order.status,
      total_amount: order.total?.amount || 0,
      delivery_date: order.expectedDeliveryDate ? order.expectedDeliveryDate.toISOString() : null,
      notes: order.notes,
      items: order.lines,
      created_by: order.createdBy,
      created_at: order.createdAt.toISOString(),
      updated_at: order.updatedAt.toISOString(),
    };
  }

  private mapToRowPartial(order: Partial<PurchaseOrder>): any {
    const row: any = {};
    if (order.status) row.status = order.status;
    if (order.total) row.total_amount = order.total.amount;
    if (order.expectedDeliveryDate) row.delivery_date = order.expectedDeliveryDate.toISOString();
    if (order.notes) row.notes = order.notes;
    if (order.lines) row.items = order.lines;
    row.updated_at = new Date().toISOString();
    return row;
  }
}
