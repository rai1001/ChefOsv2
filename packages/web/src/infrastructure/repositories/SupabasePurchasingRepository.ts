import { injectable } from 'inversify';
import { supabase } from '@/config/supabase';
import { PurchaseOrder, Money } from '@culinaryos/core';
import { IPurchasingRepository } from './FirebasePurchasingRepository';

@injectable()
export class SupabasePurchasingRepository implements IPurchasingRepository {
  async getOrdersByOutlet(outletId: string): Promise<PurchaseOrder[]> {
    const { data, error } = await supabase
      .from('purchase_orders')
      .select('*')
      .eq('outlet_id', outletId);

    if (error) throw error;
    return (data || []).map(this.mapToDomain);
  }

  async createOrder(order: PurchaseOrder): Promise<void> {
    const { error } = await supabase.from('purchase_orders').insert(this.mapToRow(order));

    if (error) throw error;
  }

  async updateOrder(id: string, order: Partial<PurchaseOrder>): Promise<void> {
    const { error } = await supabase
      .from('purchase_orders')
      .update(this.mapToRowPartial(order))
      .eq('id', id);

    if (error) throw error;
  }

  private mapToDomain(row: any): PurchaseOrder {
    return {
      id: row.id,
      outletId: row.outlet_id,
      orderNumber: row.id.substring(0, 8).toUpperCase(),
      supplier: row.supplier_id,
      status: row.status as any,
      lines: row.items || [],
      total: new Money(row.total_amount || 0, 'EUR'),
      isAutoGenerated: false,
      expectedDeliveryDate: row.delivery_date ? new Date(row.delivery_date) : undefined,
      actualDeliveryDate: undefined,
      notes: row.notes,
      createdBy: row.created_by,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
      approvedAt: undefined,
      subtotal: new Money(row.total_amount || 0, 'EUR'),
      tax: new Money(0, 'EUR'),
    } as unknown as PurchaseOrder;
  }

  private mapToRow(order: PurchaseOrder): any {
    return {
      id: order.id,
      outlet_id: order.outletId,
      supplier_id: order.supplier,
      status: order.status,
      total_amount: order.total?.amount || 0,
      delivery_date: order.expectedDeliveryDate ? order.expectedDeliveryDate.toISOString() : null,
      notes: order.notes,
      items: order.lines,
      created_by: order.createdBy,
      created_at: order.createdAt.toISOString(),
      updated_at: order.updatedAt.toISOString(),
    };
  }

  private mapToRowPartial(order: Partial<PurchaseOrder>): any {
    const row: any = {};
    if (order.status) row.status = order.status;
    if (order.total) row.total_amount = order.total.amount;
    if (order.expectedDeliveryDate) row.delivery_date = order.expectedDeliveryDate.toISOString();
    if (order.notes) row.notes = order.notes;
    if (order.lines) row.items = order.lines;
    row.updated_at = new Date().toISOString();
    return row;
  }
}
