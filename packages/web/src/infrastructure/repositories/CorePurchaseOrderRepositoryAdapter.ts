import { injectable } from 'inversify';
import { db } from '@/config/firebase';
import {
  collection,
  doc,
  setDoc,
  getDoc,
  getDocs,
  query,
  where,
  updateDoc,
  deleteDoc,
  Timestamp,
} from 'firebase/firestore';
import {
  IPurchaseOrderRepository,
  PurchaseOrder,
  CreatePurchaseOrderDTO,
  ApprovePurchaseOrderDTO,
  PurchaseOrderStatus,
  Money,
} from '@culinaryos/core';
import { useStore } from '@/presentation/store/useStore';
import { NotFoundError } from '@culinaryos/core/domain/exceptions/AppError';

@injectable()
export class CorePurchaseOrderRepositoryAdapter implements IPurchaseOrderRepository {
  private collectionName = 'purchaseOrders';

  // Helper to map Firestore data to Entity
  private mapDocToEntity(id: string, data: any): PurchaseOrder {
    return {
      ...data,
      id,
      createdAt:
        data.createdAt instanceof Timestamp ? data.createdAt.toDate() : new Date(data.createdAt),
      updatedAt:
        data.updatedAt instanceof Timestamp ? data.updatedAt.toDate() : new Date(data.updatedAt),
      expectedDeliveryDate: data.expectedDeliveryDate
        ? data.expectedDeliveryDate instanceof Timestamp
          ? data.expectedDeliveryDate.toDate()
          : new Date(data.expectedDeliveryDate)
        : undefined,
      actualDeliveryDate: data.actualDeliveryDate
        ? data.actualDeliveryDate instanceof Timestamp
          ? data.actualDeliveryDate.toDate()
          : new Date(data.actualDeliveryDate)
        : undefined,
      approvedAt: data.approvedAt
        ? data.approvedAt instanceof Timestamp
          ? data.approvedAt.toDate()
          : new Date(data.approvedAt)
        : undefined,
      lines: (data.lines || []).map((line: any) => ({
        ...line,
        unitCost: line.unitCost
          ? new Money(line.unitCost.amount, line.unitCost.currency)
          : undefined,
        totalCost: line.totalCost
          ? new Money(line.totalCost.amount, line.totalCost.currency)
          : undefined,
      })),
      total: data.total ? new Money(data.total.amount, data.total.currency) : undefined,
      subtotal: data.subtotal ? new Money(data.subtotal.amount, data.subtotal.currency) : undefined,
      tax: data.tax ? new Money(data.tax.amount, data.tax.currency) : undefined,
    } as PurchaseOrder;
  }

  /**
   * Creates a new purchase order.
   * @param dto - Data to create the purchase order.
   * @returns The created Purchase Order entity.
   */
  async create(dto: CreatePurchaseOrderDTO): Promise<PurchaseOrder> {
    const id = doc(collection(db, this.collectionName)).id;
    const now = new Date();
    const currentUser = useStore.getState().currentUser;

    // Calculate totals
    const formattedLines = dto.lines.map((line) => {
      const unitCost = line.unitCost
        ? new Money(line.unitCost.amount, line.unitCost.currency)
        : new Money(0, 'EUR');
      const totalCost = unitCost.multiply(line.quantity.value);
      return {
        ...line,
        // Ensure ingredientName is present. If missing, use a placeholder or ID.
        // Ideally this should be passed in DTO or fetched.
        ingredientName: (line as any).ingredientName || 'Unknown Ingredient',
        unitCost,
        totalCost,
      };
    });

    const totalAmount = formattedLines.reduce(
      (sum, line) => {
        return sum.add(line.totalCost);
      },
      new Money(0, 'EUR')
    );

    const purchaseOrder: PurchaseOrder = {
      id,
      ...dto,
      status: PurchaseOrderStatus.DRAFT,
      createdAt: now,
      updatedAt: now,
      isAutoGenerated: dto.isAutoGenerated || false,
      lines: formattedLines,
      total: totalAmount,
      createdBy: currentUser?.email || 'system',
      orderNumber: id.substring(0, 8).toUpperCase(), // Simple generation
      supplier: dto.supplier,
      outletId: dto.outletId,
    };

    // Prepare for Firestore (convert Money to JSON)
    const firestoreData = {
      ...purchaseOrder,
      lines: purchaseOrder.lines.map((l) => ({
        ...l,
        unitCost: l.unitCost?.toJSON(),
        totalCost: l.totalCost?.toJSON(),
      })),
      total: purchaseOrder.total?.toJSON(),
      createdAt: Timestamp.fromDate(now),
      updatedAt: Timestamp.fromDate(now),
    };

    // Remove undefined fields to avoid Firestore errors
    Object.keys(firestoreData).forEach(
      (key) => (firestoreData as any)[key] === undefined && delete (firestoreData as any)[key]
    );

    await setDoc(doc(db, this.collectionName, id), firestoreData);

    return purchaseOrder;
  }

  async findById(id: string): Promise<PurchaseOrder | null> {
    const docRef = doc(db, this.collectionName, id);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      return this.mapDocToEntity(docSnap.id, docSnap.data());
    }
    return null;
  }

  async findByOutletId(outletId: string): Promise<PurchaseOrder[]> {
    const q = query(collection(db, this.collectionName), where('outletId', '==', outletId));
    const snapshot = await getDocs(q);
    return snapshot.docs.map((d) => this.mapDocToEntity(d.id, d.data()));
  }

  async findByStatus(outletId: string, status: PurchaseOrderStatus): Promise<PurchaseOrder[]> {
    const q = query(
      collection(db, this.collectionName),
      where('outletId', '==', outletId),
      where('status', '==', status)
    );
    const snapshot = await getDocs(q);
    return snapshot.docs.map((d) => this.mapDocToEntity(d.id, d.data()));
  }

  async findAutoGenerated(outletId: string): Promise<PurchaseOrder[]> {
    const q = query(
      collection(db, this.collectionName),
      where('outletId', '==', outletId),
      where('type', '==', 'AUTOMATIC')
    );
    const snapshot = await getDocs(q);
    return snapshot.docs.map((d) => this.mapDocToEntity(d.id, d.data()));
  }

  async approve(dto: ApprovePurchaseOrderDTO): Promise<PurchaseOrder> {
    const order = await this.findById(dto.orderId);
    if (!order) throw new NotFoundError('Order not found');

    const now = new Date();
    const updates = {
      status: PurchaseOrderStatus.APPROVED,
      approvedBy: dto.approvedBy,
      approvedAt: Timestamp.fromDate(now),
      updatedAt: Timestamp.fromDate(now),
    };

    await updateDoc(doc(db, this.collectionName, dto.orderId), updates);

    return {
      ...order,
      status: PurchaseOrderStatus.APPROVED,
      approvedBy: dto.approvedBy,
      approvedAt: now,
      updatedAt: now,
    };
  }

  async update(id: string, updates: Partial<PurchaseOrder>): Promise<PurchaseOrder> {
    const now = new Date();
    // Exclude fields that shouldn't be directly updated if necessary or format them
    const firestoreUpdates = {
      ...updates,
      updatedAt: Timestamp.fromDate(now),
    };

    await updateDoc(doc(db, this.collectionName, id), firestoreUpdates);

    const updated = await this.findById(id);
    if (!updated) throw new Error('Order not found after update');
    return updated;
  }

  async updateStatus(id: string, status: PurchaseOrderStatus): Promise<PurchaseOrder> {
    const now = new Date();
    await updateDoc(doc(db, this.collectionName, id), {
      status,
      updatedAt: Timestamp.fromDate(now),
    });

    const updated = await this.findById(id);
    if (!updated) throw new Error('Order not found after update');
    return updated;
  }

  async delete(id: string): Promise<void> {
    await deleteDoc(doc(db, this.collectionName, id));
  }
}
