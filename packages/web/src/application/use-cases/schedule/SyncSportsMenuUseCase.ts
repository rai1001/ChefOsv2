import { injectable, inject } from 'inversify';
import { TYPES } from '../../di/types';
import { CalculateRequirementsUseCase, Requirement } from './CalculateRequirementsUseCase';
import { IProductionRepository } from '@/infrastructure/repositories/FirebaseProductionRepository';
import { IPurchasingRepository } from '@/infrastructure/repositories/FirebasePurchasingRepository';
import { IIngredientRepository } from '@/domain/interfaces/repositories/IIngredientRepository';
import { Event } from '@/domain/entities/Event';
import {
    ProductionTask,
    ProductionTaskStatus,
    ProductionStation,
    TaskPriority,
    PurchaseOrder,
    PurchaseOrderStatus,
    Quantity,
    Unit
} from '@culinaryos/core';
import { v4 as uuidv4 } from 'uuid';

export interface SyncSportsMenuDTO {
    event: Event;
    allItems: any[];
    matches: Record<string, { id: string, type: 'recipe' | 'ingredient' }>;
    selectedTasks: string[]; // uids
    selectedPurchases: string[]; // uids
    outletId: string;
    userId: string;
}

@injectable()
export class SyncSportsMenuUseCase {
    constructor(
        @inject(TYPES.CALCULATE_REQUIREMENTS_USE_CASE) private calculateRequirements: CalculateRequirementsUseCase,
        @inject(TYPES.PRODUCTION_REPOSITORY) private productionRepository: IProductionRepository,
        @inject(TYPES.PURCHASING_REPOSITORY) private purchasingRepository: IPurchasingRepository,
        @inject(TYPES.IngredientRepository) private ingredientRepository: IIngredientRepository,
    ) { }

    async execute(dto: SyncSportsMenuDTO): Promise<void> {
        const { event, allItems, matches, selectedTasks, selectedPurchases, outletId, userId } = dto;

        // 1. Sync Production Tasks
        for (const uid of selectedTasks) {
            const item = allItems.find(i => i.uid === uid);
            const match = matches[uid];
            if (!item || !match) continue;

            const task: ProductionTask = {
                id: uuidv4(),
                outletId,
                eventId: event.id,
                fichaId: match.id,
                fichaName: item.name,
                quantity: new Quantity(item.quantity ? parseFloat(item.quantity) : event.pax, new Unit('pax' as any)),
                station: ProductionStation.PREP,
                priority: TaskPriority.MEDIUM,
                status: ProductionTaskStatus.PENDING,
                scheduledFor: new Date(event.date),
                createdBy: userId,
                createdAt: new Date(),
                updatedAt: new Date()
            };
            await this.productionRepository.createTask(task);
        }

        // 2. Sync Purchasing (Draft Orders)
        if (selectedPurchases.length > 0) {
            const requirementsInput: { id: string, type: 'recipe' | 'ingredient', quantity: number }[] = [];

            for (const uid of selectedPurchases) {
                const item = allItems.find(i => i.uid === uid);
                const match = matches[uid];
                if (!item || !match) continue;

                requirementsInput.push({
                    id: match.id,
                    type: match.type,
                    quantity: item.quantity ? parseFloat(item.quantity) : event.pax
                });
            }

            const requirements: Requirement[] = await this.calculateRequirements.execute(requirementsInput);

            // Group requirements by supplier
            const bySupplier: Record<string, Requirement[]> = {};
            for (const req of requirements) {
                const ing = await this.ingredientRepository.getIngredientById(req.ingredientId);
                const supplierId = ing?.supplierId || 'MANUAL';
                if (!bySupplier[supplierId]) bySupplier[supplierId] = [];
                bySupplier[supplierId].push(req);
            }

            // Create a draft order for each supplier
            for (const [supplierId, reqs] of Object.entries(bySupplier)) {
                const order: PurchaseOrder = {
                    id: uuidv4(),
                    outletId,
                    orderNumber: `PED-${new Date().toISOString().slice(0, 10).replace(/-/g, '')}-${uuidv4().slice(0, 4)}`.toUpperCase(),
                    supplier: supplierId,
                    status: PurchaseOrderStatus.DRAFT,
                    lines: reqs.map(r => ({
                        ingredientId: r.ingredientId,
                        ingredientName: r.ingredientName,
                        quantity: new Quantity(r.totalQuantity, new Unit(r.unit as any))
                    })),
                    isAutoGenerated: true,
                    createdBy: userId,
                    createdAt: new Date(),
                    updatedAt: new Date()
                };
                await this.purchasingRepository.createOrder(order);
            }
        }
    }
}
